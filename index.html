<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Prediction Market MVP</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    function PredictionApp() {
      const ASSETS = ["BTC","ETH","BNB","TON"];
      const ROUND_TIME = 300;
      const LOCK_TIME = 1;
      const MIN_BET = 5;
      const FEE_PERCENT = 5;

      const [assetStates, setAssetStates] = useState(() => {
        const init = {};
        ASSETS.forEach(a => {
          init[a] = {
            price: 0,
            lockedPrice: null,
            previousLockedPrice: null,
            direction: null,
            timer: ROUND_TIME,
            status: "betting",
            bets: [],
            prizePool: 0,
            lastPrize: null
          };
        });
        return init;
      });

      const [currentAsset, setCurrentAsset] = useState("TON");
      const [walletConnected, setWalletConnected] = useState(false);
      const [balance, setBalance] = useState(0);

      const connectWallet = () => {
        setWalletConnected(true);
        setBalance(100);
      };

      const handleBet = (asset, dir) => {
        if(!walletConnected) return alert("Connect your TON Wallet first");
        if(balance < MIN_BET) return alert("Insufficient balance");

        setAssetStates(prev => {
          const updated = {...prev};
          const newBet = {direction: dir, result: null, amount: MIN_BET};
          updated[asset] = {
            ...updated[asset],
            direction: dir,
            bets: [...updated[asset].bets, newBet],
            prizePool: updated[asset].prizePool + MIN_BET
          };
          return updated;
        });
        setBalance(prev => prev - MIN_BET);
      };

      // Fetch real prices from Binance API
      useEffect(() => {
        const fetchPrices = async () => {
          try {
            const [resBTC, resETH, resBNB, resTON] = await Promise.all([
              fetch("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT"),
              fetch("https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT"),
              fetch("https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT"),
              fetch("https://api.binance.com/api/v3/ticker/price?symbol=TONUSDT")
            ]);

            const [dataBTC, dataETH, dataBNB, dataTON] = await Promise.all([
              resBTC.json(), resETH.json(), resBNB.json(), resTON.json()
            ]);

            setAssetStates(prev => ({
              ...prev,
              BTC: {...prev.BTC, price: parseFloat(dataBTC.price)},
              ETH: {...prev.ETH, price: parseFloat(dataETH.price)},
              BNB: {...prev.BNB, price: parseFloat(dataBNB.price)},
              TON: {...prev.TON, price: parseFloat(dataTON.price)},
            }));
          } catch(e) {
            console.error("Error fetching prices", e);
          }
        };

        fetchPrices();
        const interval = setInterval(fetchPrices, 5000);
        return () => clearInterval(interval);
      }, []);

      // Timer and round logic
      useEffect(() => {
        const interval = setInterval(() => {
          setAssetStates(prev => {
            const updated = {...prev};
            ASSETS.forEach(a => {
              const state = updated[a];
              if(state.timer <= 0){
                if(state.status === "betting"){
                  state.previousLockedPrice = state.lockedPrice; // сохранить для изменения относительно прошлого раунда
                  state.lockedPrice = state.price;
                  state.status = "locked";
                  state.timer = LOCK_TIME;
                } else if(state.status === "locked"){
                  state.status = "ended";
                  state.bets.forEach(bet => {
                    bet.result = state.price > state.lockedPrice ? (bet.direction === "UP") : (bet.direction === "DOWN");
                    if(bet.result) setBalance(prev => prev + bet.amount * (1 - FEE_PERCENT/100));
                  });
                  state.lastPrize = {
                    lockedPrice: state.lockedPrice,
                    prizePool: state.prizePool,
                    result: state.price > state.lockedPrice ? "UP" : "DOWN"
                  };
                  state.prizePool = 0;
                  state.bets = [];
                }
              } else {
                state.timer -= 1;
              }
            });
            return updated;
          });
        }, 1000);
        return () => clearInterval(interval);
      }, []);

      const state = assetStates[currentAsset];
      const priceChange = state.previousLockedPrice ? (state.price - state.previousLockedPrice).toFixed(2) : null;

      return (
        <div className="min-h-screen p-4">
          <div className="max-w-md mx-auto bg-white rounded-2xl shadow p-4">
            <h1 className="text-xl font-bold mb-2">Prediction Market</h1>

            {!walletConnected && <button onClick={connectWallet} className="mb-4 w-full py-2 rounded-xl bg-yellow-400 font-bold">Connect TON Wallet</button>}
            {walletConnected && <div className="mb-4 text-sm">Balance: {balance.toFixed(2)} TON</div>}

            <div className="flex gap-2 mb-4">
              {ASSETS.map(a => (
                <button key={a} onClick={() => setCurrentAsset(a)} className={`px-3 py-1 rounded-full text-sm ${currentAsset===a?"bg-blue-600 text-white":"bg-gray-200"}`}>
                  {a}
                </button>
              ))}
            </div>

            <div className="flex justify-between mb-2">
              <span>Live price</span>
              <span className="font-mono">${state.price}</span>
            </div>

            {state.previousLockedPrice && (
              <div className="flex justify-between mb-2 text-sm">
                <span>Change vs last round</span>
                <span className={`font-mono ${priceChange >= 0 ? 'text-green-600' : 'text-red-600'}`}>{priceChange}</span>
              </div>
            )}

            {state.lockedPrice && (
              <div className="flex justify-between mb-2 text-sm">
                <span>Locked price</span>
                <span className="font-mono">${state.lockedPrice}</span>
              </div>
            )}

            <div className="my-4 text-center">
              <div className="text-xs text-gray-400">Min bet: {MIN_BET} TON · Fee: {FEE_PERCENT}%</div>
              <div className="text-2xl font-bold">{state.timer}s</div>
              <div className="text-xs text-gray-500">{state.status.toUpperCase()}</div>
            </div>

            {state.status === "betting" && walletConnected && (
              <div className="grid grid-cols-2 gap-2">
                <button onClick={() => handleBet(currentAsset,"UP")} className={`p-3 rounded-xl font-bold ${state.direction === "UP" ? "bg-green-600 text-white" : "bg-green-100"}`}>UP</button>
                <button onClick={() => handleBet(currentAsset,"DOWN")} className={`p-3 rounded-xl font-bold ${state.direction === "DOWN" ? "bg-red-600 text-white" : "bg-red-100"}`}>DOWN</button>
              </div>
            )}

            {state.status === "ended" && (
              <div className="mt-4 text-center font-bold">
                Result: {state.price > state.lockedPrice ? "UP" : "DOWN"}
                {state.lastPrize && (
                  <div className="mt-2 text-sm">
                    Last Prize: Locked Price ${state.lastPrize.lockedPrice}, Prize Pool {state.lastPrize.prizePool} TON, Result {state.lastPrize.result}
                  </div>
                )}
                <div className="mt-2 text-sm">
                  Bets:
                  <ul>
                    {state.bets.map((b,i) => (
                      <li key={i}>{b.direction} ({b.amount} TON) → {b.result ? "WIN" : "LOSE"}</li>
                    ))}
                  </ul>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<PredictionApp />, document.getElementById('root'));
  </script>
</body>
</html>
